# Page Read Statistics
1. Page read statistics

We saw that with STATISTICS TIME we could get a measure the total time a query takes to run. Another way we can review query performance is by examining the amount of disk or memory activity generated by the query. We can do this by using the STATISTICS IO command.
2. Table data pages

Before we start, we need a brief understanding of how data is stored in a database table. All data, either memory or on the disk, is stored in 8 kilobyte size "pages". Depending on the size of each row of data, a single page could store many rows, or just one value could span multiple pages. A page can only belong to one table. If the tables are small, each table would require it's own page. SQL Server will do most of its work from pages cached in memory. If a query requests a page that is not in memory it is read from the disk into the memory cache.
3. Customers: data pages

This is an example how we might imagine the first four data pages of our Customers table is stored.
4. STATISTICS IO in SSMS

Like STATISTICS TIME, STATISTICS IO is initiated before running a query with SET STATISTICS IO ON. The statistics are displayed in SSMS in the Messages tab to the right of the Results tab.
5. Logical reads

All the statistics reported by STATISTICS IO are useful for query performance tuning. However, as an introduction to STATISTICS IO in this lesson, we’ll focus on the logical reads measure and how it might be used to tune query performance. Logical reads are reported for each table. They are a measure of the number of the 8 kilobyte pages read from memory to process and return the results of our query. In general, the more pages that need to be read the slower our query will run.
6. Example: query 1

Let's look at an example of the logical reads measure using STATISTICS IO. Our query returns the maximum earthquake Magnitude where a country capital city was the closest city to an earthquake of magnitude 7.5 or higher. This query uses three sub-queries:
7. Example: query 1

The first is a correlated sub-query in the SELECT statement to get the maximum magnitude earthquake.
8. Example: query 1

The second is another correlated sub-query to check for the presence of country capitals in the Earthquakes table.
9. Example: query 1

And the third sub-query applies a filter to be passed back to the Nations table.
10. Example: query 1

To get the statistics to display, we run SET STATISTICS IO ON before executing our query. The results are reported against each table that participates in the query. The output shows fifty-four pages read from the Earthquakes table and three pages read from the Nations table.
11. Example: query 2

We can re-write the query this time using an INNER JOIN between the Nations and Earthquakes tables. Because STATISTICS IO is already on we do need to rerun it.
12. Example: query 2

The output shows the same amount of page reads from the Nations table, three, but three times fewer page reads of the Earthquakes table, only eighteen. Once we’ve completed our assessment of the statistics, we turn it off by running SET STATISTICS IO OFF.
13. Comparing queries

Using an INNER JOIN on the Earthquakes table, in the second query, the entire table was read once when the query was processed, eighteen pages. Multiply that by the number of sub-queries accessing the Earthquakes table in the first query, and this increases to fifty-four. Therefore we may expect the first query to run slower than the second because more pages are accessed. We can confirm this by running the STATISTICS TIME command on each query, twenty-nine milliseconds for the first query and three milliseconds for the second. 


## Indexes
1. Indexes

When it comes to query performance tuning, adding an index to a table can be a game changer. In this lesson we'll examine a brief overview of indexes and how they can be used to improve query performance.
2. What is an index?

An index is a structure added to a table to improve the speed of accessing data. Indexes are used to locate data quickly without having to scan or search every row in a table, this makes them particularly useful for improving performance of queries with filter conditions. Indexes are applied to table columns and they can be added at any time. Adding an index to a table is typically done by the database administrator. SQL Server supports several different index types. The two most common table indexes are Clustered and Nonclustered.
3. Clustered and nonclustered indexes

A good analogy for a clustered index is a dictionary where words are stored alphabetically. With a clustered index the data, in the data pages, are stored and ordered by the column(s) with the index. Because the data is ordered one way, a table can only have one clustered index. Clustered indexes reduce the number of data page reads by a query which helps speed up search operations.
4. Clustered and nonclustered indexes

For a nonclustered index a good analogy is a text book with an index at the back. Data in the book is unordered and the index at the back indicates the page numbers containing a search condition. Like a text book a table with a nonclustered index allows data to be unordered in the table data pages. Another layer in the index structure contains ordered pointers to the data pages. A table can contain more than one nonclustered index. Nonclustered indexes are commonly used to improve table insert and update operations.
5. Clustered index: B-tree structure

Let's take a look at how a clustered index can improve performance. A clustered index creates what is called a B-tree structure on a table. We can think of a B-tree as an upside tree where the trunk is called the root node, branches the branch nodes, and leaves the page nodes.
6. Clustered index: B-tree structure

The root node contains ordered pointers to branch nodes which in turn contain ordered pointers to page nodes. The page node level contains all the 8 kilobyte data pages from the table with the data physically ordered by the column(s) with the clustered index. Without a clustered index, there is no guarantee the data is ordered in the table data pages.
7. Customers table without clustered index

Using our Customers table as an example, if we queried for all rows where CustomerID is equal to PARIS, without an index, all pages in the table would be scanned for a match.
8. Customers table without clustered index

9. Customers table without clustered index

10. Customers table without clustered index

11. Customers table with clustered index

If our Customers table has a clustered index on CustomerID, then the search would enter the B-tree at pointers nearest to our match,
12. Customers table with clustered index

in this case, between OLDWO and WOLZA.
13. Customers table with clustered index

The ordered pointers at each branch node would in turn direct the search to the
14. Customers table with clustered index

page, or pages,
15. Customers table with clustered index

containing the CustomerID we’re searching for.
16. Clustered index: example

Let’s look at this in action. We’ll query the PlayerStats table for all rows where the Team is Oklahoma City, team code OKC. We’ll turn on STATISTICS IO so we can determine the number of page reads used by our query. Without an index the whole table is scanned for rows that meet the filter condition, logical reads indicate twelve pages read. When we add a clustered index to the Team column, the number of page reads drops to two. In general, the fewer pages read to complete the query, the faster it will run. 

## Execution plans
1. Execution plans

In this final lesson, we’ll introduce SQL Execution Plans and some basic examples of what they can tell us.
2. Optimization phase

When a query is submitted to a database engine, after passing all the syntax, table, and data checks, it is passed to an Optimization Phase,
3. Optimization phase

which evaluates several execution plans to determine which one will return results at the lowest cost. Among other parameters costs include processor usage, memory usage, and data pages read.
4. Optimization phase

Once the best execution plan is selected, it is passed to the Execution Engine to process the query.
5. Information from execution plans

Reading execution plans is useful. Among other important information, they can tell us: if indexes were used, the types of joins used, if and where filter conditions, sorting and aggregations occurred, and their relative costs. Any issue with a query should be immediately apparent in an execution plan which makes it an excellent tool for troubleshooting query performance.
6. Estimated execution plan in SSMS

This image shows how we can view an estimated execution plan in SSMS. We highlight the query
7. Estimated execution plan in SSMS

and select the Display Estimated Execution Plan icon from the menu toolbar.
8. Viewing executions plans in SSMS

A graphical execution plan for the query is displayed in the Execution plan tab.
9. Operator statistics

Each icon in an execution plan represents an operator that is used to perform a specific task. Hovering over an operator provides detailed statistics of the task used in the query.
10. Reading execution plans

Execution plans are read from right to left, as indicated by the direction of the arrows between operators. The width of each arrow reflects how much data was passed from one operator to the next.
11. Index example

Let’s take a look at some of the information execution plans can provide us. An execution plan can tell us if an index is accessed while processing the query. In this example, we have two versions of the Customers table from the Customers Orders database. CustomersCI has a clustered index on the CustomerID column, and Customers does not. We’ll query both tables for a CustomerID of PARIS. The execution plan for the query on the Customers table shows a Table Scan operator. This operator indicates the entire table was scanned for the filter condition. In contrast, the execution plan for the query on the CustomersCI table shows a Clustered Index Seek operator. This operator indicates an index was used to go directly to the data pages that meet the filter condition.
12. Sort operator example

In an earlier chapter, we said that we could append queries together using UNION and UNION ALL. We noted that UNION removes duplicates and UNION ALL returns everything, including duplicates. To check for and remove duplicates requires a sort operation. We can see this by comparing two queries with UNION and UNION ALL. The execution plan with UNION uses a Sort operator internally to check and remove duplicates and UNION ALL does not. Be aware of the Sort operator in execution plans because it can be costly on a query. Examining an execution plan could tell us particular syntax or operators that are unnecessary.
13. The same execution plan?

Often, queries using different methods to return the same result will produce the same execution plan. In an earlier chapter, we compared the IN and EXISTS operators. In this example we have two simple queries: one using IN and the other EXISTS. The optimizer has decided to use the same execution plan for both. This is not always the case, and it does not mean that we should let the optimizer do all the query performance tuning for us. If time is important, we should always ask ourselves if there is a better or faster way to return the results we require. 